---
title: "Model code walkthrough"
authors:
  - name: Amy Heather
    url: https://github.com/amyheather
    orcid: 0000-0002-6596-3479
    affiliation: University of Exeter
format:
  html:
    toc: true
bibliography: ../docs/references.bib
csl: ../docs/elsvan.csl
---

## Purpose of this notebook

This is a (potentially temporary) notebook that I am keeping as I work through the model (copied from `Model_Structure.R`), writing down notes to explain each part to myself, to ensure I understand it.

To simplify this, I have removed the original comments, and so this just includes my comments that I needed to understand it. The benefit of this is that, once I have understood how it all works, I can use my comments below to inform any changes to the comments in `Model_Structure.R`, the function docstrings, or elsewhere. Once I have completed this notebook, I can also create the model overview pages.

::: {.callout-warning}

Whenever I have made changes to the code in `Model_Structure.R`, these are indicated with these boxes. This is excluding the removal of comments, which has been done throughout.

:::

::: {.callout-note collapse="false"}

Whenever I have add code or detailed explanation, to help explain and demonstrate what the model is doing, these are contained within these boxes.

:::

## Set up

### Import libraries

```{r}
#| output: false

library(shiny, quiet = TRUE)   
library(gtools, quiet = TRUE)
library(openxlsx, quiet = TRUE)
library(flexsurv, quiet = TRUE)
library(tidyverse, quiet = TRUE)
library(data.table, quiet = TRUE)
library(heemod, quiet = TRUE)
library(logOfGamma, quiet = TRUE)
library(ggplot2, quiet = TRUE)
library(survminer, quiet = TRUE)
library(officer, quiet = TRUE)
library(officedown, quiet = TRUE)
library(magrittr, quiet = TRUE)
library(Hmisc, quiet = TRUE)
library(future.apply, quiet = TRUE)
library(crosstable, quiet = TRUE)
library(flextable, quiet = TRUE)
library(stringr, quiet = TRUE)
library(BCEA, quiet = TRUE)
library(collapse, quiet = TRUE)
library(scales, quiet = TRUE)
library(Matrix, quiet = TRUE)
library(dplyr, quiet = TRUE)
library(progressr, quiet = TRUE)
library(microbenchmark, quiet = TRUE)
```

### Define some project settings

```{r}
keep_free_cores <- NA
if (any(is.na(keep_free_cores), keep_free_cores<0)) {
  plan(sequential)
} else {
  plan(multisession(workers = max(availableCores()-keep_free_cores,1)))
}
```

::: {.callout-note collapse="true"}

Recorded time to get to **complete 3 active treatment lines for population 1**, then repeated with other cores, to understand what is faster / slower:

* 28 cores: > 53m (still on 3)
* 12 cores: 35m
* 8 cores: < 19m
* 4 cores: 7m
* Sequential (i.e. `NA`): 3m

To run full script **sequentially** on that **remote machine**, it took **19 minutes**.

:::

```{r}
# Other generic settings for the progress bar and units for table widths
handlers("progress")
options(crosstable_units="cm")
```

::: {.callout-note collapse="true"}

`handlers("progress")`: `progressr` function, settings for how progress is reported

`options(crosstable_units="cm")`: `crosstable` package generates descriptive statistics with function `crosstable()`, and this is the settings for it (although can't spot us of `crosstable()` anywhere)

:::

```{r}
qc_mode <- FALSE
```

::: {.callout-note collapse="true"}

`qc_mode` is just used in `survival_functions.R` and by `f_NMA_AddAssumptionsToNetwork()` (and perhaps others if it calls them) and it is the input for `verbose` (i.e. if true, there will be extra outputs to console)

:::

### Get functions

::: {.callout-warning collapse="true"}

I've modified this to make path defined once, as needed to change it, and to define paths that occur later on in the script. Hence, you'll spot the changes later in the code also for `excel_path` and `empty_results_path`.

:::

```{r}
# Set path to folders
path_data = "../1_Data/"
path_functions = "../3_Functions/"

# Set paths to files loaded in this script
excel_path <- file.path(path_data, "ID6184_RCC_model inputs FAD version [UK RWE unredacted, ACIC redacted, cPAS redacted].xlsm")
empty_results_path = file.path(path_functions, "reporting/empty results doc.docx")

# Source functions
source(file.path(path_functions, "excel/extract.R"))
source(file.path(path_functions, "sequencing/sequences.R"))
source(file.path(path_functions, "survival/Survival_functions.R"))
source(file.path(path_functions, "survival/other_cause_mortality.R"))
source(file.path(path_functions, "survival/treatment_effect_waning.R"))
source(file.path(path_functions, "misc/other.R"))
source(file.path(path_functions, "misc/shift_and_pad.R"))
source(file.path(path_functions, "misc/cleaning.R"))
source(file.path(path_functions, "misc/nesting.R"))
source(file.path(path_functions, "misc/discounting.R"))
source(file.path(path_functions, "misc/qdirichlet.R"))
source(file.path(path_functions, "misc/plotting.R"))
source(file.path(path_functions, "misc/structure.R"))
source(file.path(path_functions, "misc/fpnma_fns.R"))
source(file.path(path_functions, "utility/age_related.R"))
source(file.path(path_functions, "costs_and_QALYs/utility_processing.R"))
source(file.path(path_functions, "adverse_events/AE_steps.R"))
source(file.path(path_functions, "costs_and_QALYs/cost_processing.R"))
source(file.path(path_functions, "markov/markov.R"))
source(file.path(path_functions, "patient_flow/overarching.R"))
source(file.path(path_functions, "patient_flow/partitioned_survival.R"))
source(file.path(path_functions, "patient_flow/markov.R"))
source(file.path(path_functions, "patient_flow/drug_costs.R"))
source(file.path(path_functions, "patient_flow/hcru_costs.R"))
source(file.path(path_functions, "patient_flow/qalys.R"))
source(file.path(path_functions, "patient_flow/ae.R"))
source(file.path(path_functions, "results/incremental_analysis.R"))
source(file.path(path_functions, "results/model_averaging.R"))
source(file.path(path_functions, "results/partitioned_survival.R"))
source(file.path(path_functions, "misc/severity_modifier.R"))
source(file.path(path_functions, "results/results_tables.R"))
source(file.path(path_functions, "psa/psa functions.R"))
source(file.path(path_functions, "reporting/word_document_output.R"))
```

::: {.callout-note collapse="true"}

Not sure of purpose as doesn't appear to be used anywhere - might be legacy code.

:::

```{r}
User_types <- c("Submitting company", "NICE", "EAG", "Committee", "NHSE", "Clinical expert", "Patient expert", "Non-intervention stakeholder", "Public")
```

## Define model parameters

### Get inputs from excel workbook and save as list `i`

::: {.callout-warning collapse="true"}

Hidden output as it is quite verbose.

:::

```{r}
if (file.exists(excel_path)) {
  i <- f_excel_extract(excel_path, verbose = FALSE)
} else {
  i <- f_excel_extract(rstudioapi::selectFile(
    caption = "Select the Excel inputs file (ID6184_RCC_model inputs....xlsm)",
    label = "ID6184_RCC_model inputs....xlsm",
    path = "../1_Data/",
    filter = "Excel Files (*.xlsm)",
    existing = TRUE
  ), verbose = FALSE)
}
```

::: {.callout-note collapse="true"}

Import the file at `excel_path` using `f_excel_extract()`. If the file doesn't exist, assuming the user is in RStudio, a dialog box will appear with the system files, and the user should then select a file from their directory. The dialog will open in `1_Data/`, show only `.xlsm` files, and the accept/ok button has the text `ID6184_RCC_model inputs....xlsm`.

The function `f_excel_extract` is below (note: `sheets` not used).

```{r}
f_excel_extract <- function(path_to_excel_file, verbose = FALSE) {
  
  wb          <- loadWorkbook(path_to_excel_file)
  sheets      <- wb$sheet_names
  named       <- getNamedRegions(wb)
  nams        <- unlist(as.list(named))
  names(nams) <- nams
  
  # Cycle through all the named ranges, making a decision on cleaning as we go
  output <- lapply(nams, function(named_range) {
    
    if (verbose) cat(paste0("Extracting named range ", named_range, " from ", path_to_excel_file, "\n"))
    dat <- read.xlsx(wb,namedRegion = named_range, check.names = TRUE,colNames = TRUE)
    
    if (nrow(dat) == 0) {
      # if it has 0 rows, then the input must be a 1 cell one, so we can safely assume
      # no row names
      dat <- read.xlsx(wb,namedRegion = named_range,colNames = FALSE,rowNames = FALSE)
      
      if (all(length(dat) == 1, names(dat)[1] == "X1")) {
        dat <- unlist(dat, use.names = FALSE)
      } else if(nrow(dat) == 1) {
        dat <- unlist(read.xlsx(wb,namedRegion = named_range,colNames = FALSE,rowNames = FALSE), use.names = F)
      } 
      
      return(dat)
    } else if(ncol(dat) == 1) {
      # if there's 1 column, then it's actually just a vector:
      dat <- unlist(read.xlsx(wb,namedRegion = named_range,colNames = FALSE,rowNames = FALSE), use.names = F)
    } else {
      # logically we can't identify whether a table has appropriate names or not
      # at this point. this will have to be left to the cleaning functions.
      return(dat)
    }
  })
  
  # Drop the workbook at the end (I think in {} this would happen anyway, but want to ensure!)
  rm(wb)
  return(output)
}
```

It loops through `named_range`, which is returned by `openxlsx::getNamedRegions()`. This is a function that finds all the named regions in an excel file.

Named regions consist of:

* A name for the region (e.g. `apply_waning_to`)
* The region, which consists of the sheet, column/s and row/s (e.g. `=Lists!$Y$10:$Y$11`)

In this workbook, the named regions are all stored in a sheet called `named ranges`.

When this function runs, it creates a list called `i` and each element of that list reflects a row from the `named ranges sheet`, except the first element, which is each of the named ranges.

Named ranges:

```{r}
head(i[[1]])
head(i$`_xlnm._FilterDatabase`)
```

**Example** `apply_waning_to` was from `=Lists!$Y$10:$Y$11`. Looking in the `Lists` sheet, we can see that Y10 was `ref trt hazard` and Y11 was `ref trt abs surv`. This matches up with the returned object:

```{r}
i[[2]]
i$apply_waning_to
```

**Example 2:** `dd_age_sex_source` is from `='Model settings'!$G$63`. Looking in the `Model settings` sheet, we can see that G63 is the answer to "Age/sex based on mean or PLD?", with base case/default being `PLD`. We can likewise see this from its value in the list:

```{r}
i[[11]]
i$dd_age_sex_source
```

:::

```{r}
i <- c(i,f_excel_cleanParams(i$R_table_param))
```

::: {.callout-note collapse="true"}

One of the items in the list `i` is `R_table_param`. The source of this in the excel workbook was `='All parameters'!$C$5:$Q$2912` - so basically, it's just taking the full table from the sheet `All parameters`.

```{r}
head(i$R_table_param)
```

The function `f_excel_cleanParams()` takes this table and turns each row into a list, which you can access using `Parameter.name`. It adds an extra element `Mean`, which is just the value from `Mean.current.value` converted to numeric.

```{r}
show_list <- f_excel_cleanParams(i$R_table_param)
show_list$cabo_nivo_include
```

When it did this, it then concatenated that list with the list `i`, meaning that each of those elements can now be accessed in the same way from `i`.

```{r}
i$cabo_nivo_include
```

:::

### Add some extra inputs to the list `i`

```{r}
i$decision_problem <- "cabo+nivo"

i$id     <- list(ipd = list())
i$lookup <- list(ipd = list())

i$distnames <- 
  c(
    gengamma      = "gengamma",
    exp           = "exp",
    weibull       = "weibull",
    lnorm         = "lnorm",
    gamma         = "gamma",
    gompertz      = "gompertz",
    llogis        = "llogis"
  )
```

### Use `i` to make new list `p` (some elements same, some used in calculations to make new elements)

```{r}
p <- f_misc_param_generate_p(i)
```

::: {.callout-note collapse="true"}

The function `structure::f_misc_param_generate_p()` simply takes some of the elements from `i` and creates a new list `p`.

For example, these are both the same:

```{r}
p$basic$th_y
i$ui_time_horizon
```

See the full outline of what elements it takes by looking at the function:

```{r}
#' Function which creates an empty version of the parameters list p and populates
#' it using the inputs from i
#' 
#' @param i raw extracted inputs from Excel
#' 
f_misc_param_generate_p <- function(i) {
  
  p <- list(
    basic = list(
      th   = ceiling(i$ui_time_horizon * 365.25 / 7), 
      th_y = i$ui_time_horizon, 
      cl_d = i$i_cycle_length_weeks*7, 
      cl_w = i$i_cycle_length_weeks, 
      cl_y = i$i_cycle_length_weeks*7/365.25, 
      discQ = i$ui_disc_qaly,
      discC = i$ui_disc_cost,
      structure = str_trim(i$dd_model_struct)
    ),
    demo = list(
      table = data.table(i$R_table_ptchar)
    ), # patient demographic data
    seq   = list(), # treatment sequences. same for both model structures.
    surv  = list(), # Survival extrapolations (if needed for iteration, i.e. in part surv model). same for both model structures
    releff = list(), # Relative efficacy network, for use populating the disease model. same for both model structures
    costs  = list(
      mk = list(),
      ps = list(),
      settings = list(
        subsTx = data.table(i$R_table_sub_txts_prop_n_costs)
      )
    ), # All drug inputs after they've been processed and tidied up
    util  = list(
      mk = list(),
      ps = list()
    ), # All inputs to apply to the disease model
    ae    = list(
      mk = list(),
      ps = list()
    ), # Inputs to generate AE matrices AC and AQ
    misc  = list(
      mk = list(),
      ps = list(),
      plot = list(
        xlim_survplots_yr = 20
      )
    )
  )
  
  p$basic$n_cyc <- ceiling(p$basic$th) # rounding up to a whole number
  p$basic$t_cyc <- rep(0:p$basic$n_cyc)
  p$basic$t_yr  <- p$basic$t_cyc*7/365.25
  
  # discount factors - base-case edition. These will get replaced for scenarios affecting
  # discount rates or the time horizon
  p$basic$discFacQ <- f_discFac(p$basic$discQ,p$basic$t_yr)
  p$basic$discFacC <- f_discFac(p$basic$discC,p$basic$t_yr)
  
  return(p)
  
}
```

:::

### Add some more inputs to `p`

```{r}
p$basic$R_maxlines <- 4

p$basic$decision_problem <- i$decision_problem
```

::: {.callout-note collapse="true"}

I'm pretty sure that max lines is referring to the maximum number of treatment lines. The most it can be is 4. But I don't know if perhaps you can change this to 2 to reduce the number in model? Or if this is a standard unchanging parameter as the model is only designed to go up to 4?

:::

### Find all the possible combinations and orders of treatment and add to `i`

```{r}
i$sequences <- f_generate_sequences(
  comparators = i$List_comparators, 
  maxlines    = p$basic$R_maxlines
)
```

::: {.callout-note collapse="true"}

This adds a new element to `i` called `sequences`.

```{r}
head(i$sequences)
```

It's created using `sequences::f_generate_sequences()`. The inputs to this were:

```{r}
i$List_comparators
p$basic$R_maxlines
```

The output of the function is a table where each column is the line of therapy. The final column is always best supportive care (BSC). The first four columns reflect every possible order and combination of treatments (e.g. ABCD, ABCE, ABCF... and so on). The total possiblities are:

```{r}
dim(i$sequences)
```

:::

<mark>its not outputting right when i run through it below, so trying it here before run full function. and it works here. although might break next part</mark>

```{r}
i$sequences <- as.data.frame(i$sequences)

populations <- i$i_nr_populations

seqs <- NULL

for (population in 1:populations) {
  sequences = i$sequences
  allowed = f_get_allowed_lists(i, population)
  print("Dropping drugs not allowed for this population.\n")
  sequences
  s <- f_path_allowed(sequences, allowed[[1]])
  s
}
```

```{r}
i$sequences <- as.data.frame(i$sequences)

populations <- i$i_nr_populations

seqs <- NULL
for (population in 1:populations) {
  cat("Applying sequence restrictions to population", population,"\n")
  
  s <- f_path_tx_restrict(
    sequences                = i$sequences,
    allowed                  = f_get_allowed_lists(i, population), #overall list of allowed drugs in this popn
    L1                       = f_get_L1_lists(i, population), # 1L drugs allowed in this popn
    L2                       = f_get_L2_lists(i, population), # 2L drugs allowed in this popn
    L3                       = f_get_L3_lists(i, population), # 3L drugs allowed in this popn
    L4                       = f_get_L4_lists(i, population), # 4L drugs allowed in this popn
    only_after               = f_get_only_after_lists(i, population), #list of restrictions where tx can be only after the listed txs
    not_immediate_after      = f_get_not_immediate_after_lists(i, population), #list of restrictions where tx can be only immediately before the listed txs
    one_in_list              = f_get_one_in_list_lists(i, population), #list of restrictions where only one of the tx in each list is allowed 
    only_after_one           = f_get_only_after_one_lists(i, population), #list of restrictions where only one of the listed treatments is allowed prior to current therapy 
    L2_only_after            = f_get_2L_only_after_lists(i, population), #list of 2L+ restrictions: if drug is used 2L, 3L or 4L, can only be after drug x
    L2_only_immediate_after  = f_get_2L_only_immediate_after_lists(i, population), #list of 2L+ restrictions: if drug is used 2L, 3L or 4L, can only be immediately after drug x
    L2_only_one              = f_get_2L_only_one_lists(i, population) #list of 2L+ drugs where only one of them allowed in a given sequence
  )
  s <- cbind(rep(paste0("pop", population),nrow(s)), s)
  colnames(s) <- paste0('V', seq_len(ncol(s))) # rbind no longer likes un-named columns so added this
  seqs <- rbind(seqs, s)
}
rownames(seqs) <- NULL

i$sequences <- seqs
```

::: {.callout-note collapse="true"}

## Introduction to `f_path_tx_restrict`

`f_path_tx_restrict` is defined in two .R files: `rccFunctions.R` and `sequences.R`. In this script, we did not use `rccFunctions.R`, and just sourced `sequences.R`.

This has substantially reduced the number of rows with possible sequence combinations in `i$sequences`:

```{r}
dim(i$sequences)
```

It utilises several other functions from `sequences.R`, each taking the input of `i` and `population`, where population is an element from:

```{r}
i$i_nr_populations
```

We can see from the excel spreadsheet that this is the value for total populations from `Lists`, and that above it it mentions the popoulations:

* pop1	>12m since IO, favourable risk
* pop2	>12m since IO, intermed/poor risk
* pop3	<12m since IO, favourable risk
* pop4	<12m since IO, intermed/poor risk

IO refers to immuno-ocology. also known as immunotherapy.

The risks are as defined in the International Metastatic Renal Cell Carcinoma Database Consortium (IMDC) criteria. RCC can be defined as either:

* **Favourable-risk** disease/cancer/RCC
* **Intermediate- and poor-risk** disease/cancer/RCC

This then guides treatment decisions:

* Treatments for all risk groups (i.e. favourable, intermediate or poor) include "sunitinib, pazopanib, tivozanib or avelumab plus axitinib"
* Additional treatments for intermediate- or poor-risk cancer are "nivolumab plus ipilimumab, lenvatinib plus pembrolizumab, or cabozantinib" @national_institute_for_health_and_care_excellence_nice_cabozantinib_2024

:::

::: {.callout-note collapse="true"}

## Explanation of `f_get_allowed_lists()`

The first function used within `f_path_tx_restrict()` is `f_get_allowed_lists()` to get the value for `allowed`.

```{r}
f_get_allowed_lists <- function(i, population) {
  output <- i[grep("allowed", names(i))]
  output <- output[grep(paste0("pop", population), names(output))]
  output <- output[!(grepl("only_one_allowed", names(output)))]
  names(output) <- sub(paste0("List_","pop",population,"_"), "", names(output))
  f_check_drugnames(i, output)
  return(output)
}
```

The first thing this function does is find all the "allowed" lists from `i`. As you can see, there are several lists defined for each population.

```{r}
output <- i[grep("allowed", names(i))]
names(output)
```

It then filters to one of the populations (`pop1`, `pop2`, `pop3` or `pop4`). For example, for `pop1`...

```{r}
population <- 1

output <- output[grep(paste0("pop", population), names(output))]
output
```
It removes the lists that said `only_one_allowed`.

```{r}
output <- output[!(grepl("only_one_allowed", names(output)))]
output
```

Finally, it renames the lists to remove the words `List` and `pop1`(2/3/4).

```{r}
names(output) <- sub(paste0("List_","pop",population,"_"), "", names(output))
output
```

This checks that each of the names in the list match the names in `i$List_comparators`, and will stop the code and return an error message if any do not.

```{r}
i$List_comparators
```

```{r}
f_check_drugnames(i, output)
```

:::

::: {.callout-note collapse="true"}

## Returning to `f_path_tx_restrict`

The result from the function above is input into `f_path_tx_restrict` as `allowed`, and used in a single line, to remove drugs not allowed for that population:

```
s <- f_path_allowed(s, allowed[[1]])
```

As a reminder, `s` and `allowed[[1]]` are:

```{r}
# Input to f_path_tx_restrict(), as allowed = f_get_allowed_lists(i, population)
allowed <- output
allowed[[1]]
```

```{r}
# Input to f_path_tx_restrict()
sequences <- i$sequences
s <- sequences
head(s)
```

We apply the function `f_path_allowed()`...

```{r}
f_path_allowed <- function(perms, rule) {
  #objective of function is to identify perms that violate rule and exclude
  cat("applying rule:", rule, "are only allowed treatments.\n")
  cat("Permutations before applying rule:", nrow(perms), "\n")
  
  rule <- c(rule, "BSC", "")
  
  for (n in 1:ncol(perms)) {
    perms <- perms[perms[,n] %in% rule,]
  }
  
  cat("Permutations after applying rule :", nrow(perms),"\n")
  return(perms)
  
}
```

So in this case...

```{r}
perms <- s
rule <- allowed[[1]]

cat("applying rule:", rule, "are only allowed treatments.\n")
cat("Permutations before applying rule:", nrow(perms), "\n")
```

It adds BSC (best supportive care) and an empty element to the list of allowed treatments

```{r}
rule <- c(rule, "BSC", "")
```

It then loops through each of the lines of treatment (columns of `perms` - V1, V2, V3, V4, V5, V6), and only keeps the rows if the treatment in that column in that row is in the list of allowed treatments.

```{r}
for (n in 1:ncol(perms)) {
  perms <- perms[perms[,n] %in% rule,]
}

cat("Permutations after applying rule :", nrow(perms),"\n")
```

```{r}
f_path_allowed(s, allowed[[1]])
```

<mark>something wrong? have i introduced an error somewhere? or is it because i've run this after already running the function above?</mark>

```{r}
f_path_allowed(sequences, f_get_allowed_lists(i, i$i_nr_populations[1]))

f_path_allowed(sequences, f_get_allowed_lists(i, "pop2"))

f_path_allowed(sequences, f_get_allowed_lists(i, "pop3"))

f_path_allowed(sequences, f_get_allowed_lists(i, "pop4"))
```

:::