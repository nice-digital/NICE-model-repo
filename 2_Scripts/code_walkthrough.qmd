---
title: "Model code walkthrough"
authors:
  - name: Amy Heather
    url: https://github.com/amyheather
    orcid: 0000-0002-6596-3479
    affiliation: University of Exeter
format:
  html:
    toc: true
bibliography: ../docs/references.bib
csl: ../docs/elsvan.csl
---

## Purpose of this notebook

This is a (potentially temporary) notebook that I am keeping as I work through the model (copied from `Model_Structure.R`), writing down notes to explain each part to myself, to ensure I understand it.

To simplify this, I have removed the original comments, and so this just includes my comments that I needed to understand it. The benefit of this is that, once I have understood how it all works, I can use my comments below to inform any changes to the comments in `Model_Structure.R`, the function docstrings, or elsewhere. Once I have completed this notebook, I can also create the model overview pages.

::: {.callout-warning}

Whenever I have made changes to the code in `Model_Structure.R`, these are indicated with these boxes. This is excluding the removal of comments, which has been done throughout.

:::

::: {.callout-note collapse="false"}

Whenever I have add code or detailed explanation, to help explain and demonstrate what the model is doing, these are contained within these boxes.

:::

## Set up

### Import libraries

```{r}
#| output: false

library(shiny, quiet = TRUE)   
library(gtools, quiet = TRUE)
library(openxlsx, quiet = TRUE)
library(flexsurv, quiet = TRUE)
library(tidyverse, quiet = TRUE)
library(data.table, quiet = TRUE)
library(heemod, quiet = TRUE)
library(logOfGamma, quiet = TRUE)
library(ggplot2, quiet = TRUE)
library(survminer, quiet = TRUE)
library(officer, quiet = TRUE)
library(officedown, quiet = TRUE)
library(magrittr, quiet = TRUE)
library(Hmisc, quiet = TRUE)
library(future.apply, quiet = TRUE)
library(crosstable, quiet = TRUE)
library(flextable, quiet = TRUE)
library(stringr, quiet = TRUE)
library(BCEA, quiet = TRUE)
library(collapse, quiet = TRUE)
library(scales, quiet = TRUE)
library(Matrix, quiet = TRUE)
library(dplyr, quiet = TRUE)
library(progressr, quiet = TRUE)
library(microbenchmark, quiet = TRUE)
```

### Define some project settings

```{r}
keep_free_cores <- NA
if (any(is.na(keep_free_cores), keep_free_cores<0)) {
  plan(sequential)
} else {
  plan(multisession(workers = max(availableCores()-keep_free_cores,1)))
}
```

::: {.callout-note collapse="true"}

Recorded time to get to **complete 3 active treatment lines for population 1**, then repeated with other cores, to understand what is faster / slower:

* 28 cores: > 53m (still on 3)
* 12 cores: 35m
* 8 cores: < 19m
* 4 cores: 7m
* Sequential (i.e. `NA`): 3m

To run full script **sequentially** on that **remote machine**, it took **19 minutes**.

:::

```{r}
# Other generic settings for the progress bar and units for table widths
handlers("progress")
options(crosstable_units="cm")
```

::: {.callout-note collapse="true"}

`handlers("progress")`: `progressr` function, settings for how progress is reported

`options(crosstable_units="cm")`: `crosstable` package generates descriptive statistics with function `crosstable()`, and this is the settings for it (although can't spot us of `crosstable()` anywhere)

:::

```{r}
qc_mode <- FALSE
```

::: {.callout-note collapse="true"}

`qc_mode` is just used in `survival_functions.R` and by `f_NMA_AddAssumptionsToNetwork()` (and perhaps others if it calls them) and it is the input for `verbose` (i.e. if true, there will be extra outputs to console)

:::

### Get functions

::: {.callout-warning collapse="true"}

I've modified this to make path defined once, as needed to change it, and to define paths that occur later on in the script. Hence, you'll spot the changes later in the code also for `excel_path` and `empty_results_path`.

:::

```{r}
# Set path to folders
path_data = "../1_Data"
path_functions = "../3_Functions"

# Set paths to files loaded in this script
excel_path <- file.path(path_data, "ID6184_RCC_model inputs FAD version [UK RWE unredacted, ACIC redacted, cPAS redacted].xlsm")
excel_path2 <- file.path(path_data, "IPD_R_input_noACIC.xlsx")
empty_results_path = file.path(path_functions, "reporting/empty results doc.docx")

# Source functions
source(file.path(path_functions, "excel/extract.R"))
source(file.path(path_functions, "sequencing/sequences.R"))
source(file.path(path_functions, "survival/Survival_functions.R"))
source(file.path(path_functions, "survival/other_cause_mortality.R"))
source(file.path(path_functions, "survival/treatment_effect_waning.R"))
source(file.path(path_functions, "misc/other.R"))
source(file.path(path_functions, "misc/shift_and_pad.R"))
source(file.path(path_functions, "misc/cleaning.R"))
source(file.path(path_functions, "misc/nesting.R"))
source(file.path(path_functions, "misc/discounting.R"))
source(file.path(path_functions, "misc/qdirichlet.R"))
source(file.path(path_functions, "misc/plotting.R"))
source(file.path(path_functions, "misc/structure.R"))
source(file.path(path_functions, "misc/fpnma_fns.R"))
source(file.path(path_functions, "utility/age_related.R"))
source(file.path(path_functions, "costs_and_QALYs/utility_processing.R"))
source(file.path(path_functions, "adverse_events/AE_steps.R"))
source(file.path(path_functions, "costs_and_QALYs/cost_processing.R"))
source(file.path(path_functions, "markov/markov.R"))
source(file.path(path_functions, "patient_flow/overarching.R"))
source(file.path(path_functions, "patient_flow/partitioned_survival.R"))
source(file.path(path_functions, "patient_flow/markov.R"))
source(file.path(path_functions, "patient_flow/drug_costs.R"))
source(file.path(path_functions, "patient_flow/hcru_costs.R"))
source(file.path(path_functions, "patient_flow/qalys.R"))
source(file.path(path_functions, "patient_flow/ae.R"))
source(file.path(path_functions, "results/incremental_analysis.R"))
source(file.path(path_functions, "results/model_averaging.R"))
source(file.path(path_functions, "results/partitioned_survival.R"))
source(file.path(path_functions, "misc/severity_modifier.R"))
source(file.path(path_functions, "results/results_tables.R"))
source(file.path(path_functions, "psa/psa functions.R"))
source(file.path(path_functions, "reporting/word_document_output.R"))
```

::: {.callout-note collapse="true"}

Not sure of purpose as doesn't appear to be used anywhere - might be legacy code.

:::

```{r}
User_types <- c("Submitting company", "NICE", "EAG", "Committee", "NHSE", "Clinical expert", "Patient expert", "Non-intervention stakeholder", "Public")
```

## Define model parameters

### Get inputs from excel workbook and save as list `i`

::: {.callout-warning collapse="true"}

Hidden output as it is quite verbose.

:::

```{r}
if (file.exists(excel_path)) {
  i <- f_excel_extract(excel_path, verbose = FALSE)
} else {
  i <- f_excel_extract(rstudioapi::selectFile(
    caption = "Select the Excel inputs file (ID6184_RCC_model inputs....xlsm)",
    label = "ID6184_RCC_model inputs....xlsm",
    path = "../1_Data/",
    filter = "Excel Files (*.xlsm)",
    existing = TRUE
  ), verbose = FALSE)
}
```

::: {.callout-note collapse="true"}

Import the file at `excel_path` using `f_excel_extract()`. If the file doesn't exist, assuming the user is in RStudio, a dialog box will appear with the system files, and the user should then select a file from their directory. The dialog will open in `1_Data/`, show only `.xlsm` files, and the accept/ok button has the text `ID6184_RCC_model inputs....xlsm`.

The function `f_excel_extract` is below (note: `sheets` not used).

```{r}
f_excel_extract <- function(path_to_excel_file, verbose = FALSE) {
  
  wb          <- loadWorkbook(path_to_excel_file)
  sheets      <- wb$sheet_names
  named       <- getNamedRegions(wb)
  nams        <- unlist(as.list(named))
  names(nams) <- nams
  
  # Cycle through all the named ranges, making a decision on cleaning as we go
  output <- lapply(nams, function(named_range) {
    
    if (verbose) cat(paste0("Extracting named range ", named_range, " from ", path_to_excel_file, "\n"))
    dat <- read.xlsx(wb,namedRegion = named_range, check.names = TRUE,colNames = TRUE)
    
    if (nrow(dat) == 0) {
      # if it has 0 rows, then the input must be a 1 cell one, so we can safely assume
      # no row names
      dat <- read.xlsx(wb,namedRegion = named_range,colNames = FALSE,rowNames = FALSE)
      
      if (all(length(dat) == 1, names(dat)[1] == "X1")) {
        dat <- unlist(dat, use.names = FALSE)
      } else if(nrow(dat) == 1) {
        dat <- unlist(read.xlsx(wb,namedRegion = named_range,colNames = FALSE,rowNames = FALSE), use.names = F)
      } 
      
      return(dat)
    } else if(ncol(dat) == 1) {
      # if there's 1 column, then it's actually just a vector:
      dat <- unlist(read.xlsx(wb,namedRegion = named_range,colNames = FALSE,rowNames = FALSE), use.names = F)
    } else {
      # logically we can't identify whether a table has appropriate names or not
      # at this point. this will have to be left to the cleaning functions.
      return(dat)
    }
  })
  
  # Drop the workbook at the end (I think in {} this would happen anyway, but want to ensure!)
  rm(wb)
  return(output)
}
```

It loops through `named_range`, which is returned by `openxlsx::getNamedRegions()`. This is a function that finds all the named regions in an excel file.

Named regions consist of:

* A name for the region (e.g. `apply_waning_to`)
* The region, which consists of the sheet, column/s and row/s (e.g. `=Lists!$Y$10:$Y$11`)

In this workbook, the named regions are all stored in a sheet called `named ranges`.

When this function runs, it creates a list called `i` and each element of that list reflects a row from the `named ranges sheet`, except the first element, which is each of the named ranges.

Named ranges:

```{r}
head(i[[1]])
head(i$`_xlnm._FilterDatabase`)
```

**Example** `apply_waning_to` was from `=Lists!$Y$10:$Y$11`. Looking in the `Lists` sheet, we can see that Y10 was `ref trt hazard` and Y11 was `ref trt abs surv`. This matches up with the returned object:

```{r}
i[[2]]
i$apply_waning_to
```

**Example 2:** `dd_age_sex_source` is from `='Model settings'!$G$63`. Looking in the `Model settings` sheet, we can see that G63 is the answer to "Age/sex based on mean or PLD?", with base case/default being `PLD`. We can likewise see this from its value in the list:

```{r}
i[[11]]
i$dd_age_sex_source
```

:::

```{r}
i <- c(i,f_excel_cleanParams(i$R_table_param))
```

::: {.callout-note collapse="true"}

One of the items in the list `i` is `R_table_param`. The source of this in the excel workbook was `='All parameters'!$C$5:$Q$2912` - so basically, it's just taking the full table from the sheet `All parameters`.

```{r}
head(i$R_table_param)
```

The function `f_excel_cleanParams()` takes this table and turns each row into a list, which you can access using `Parameter.name`. It adds an extra element `Mean`, which is just the value from `Mean.current.value` converted to numeric.

```{r}
show_list <- f_excel_cleanParams(i$R_table_param)
show_list$cabo_nivo_include
```

When it did this, it then concatenated that list with the list `i`, meaning that each of those elements can now be accessed in the same way from `i`.

```{r}
i$cabo_nivo_include
```

:::

### Add some extra inputs to the list `i`

```{r}
i$decision_problem <- "cabo+nivo"

i$id     <- list(ipd = list())
i$lookup <- list(ipd = list())

i$distnames <- 
  c(
    gengamma      = "gengamma",
    exp           = "exp",
    weibull       = "weibull",
    lnorm         = "lnorm",
    gamma         = "gamma",
    gompertz      = "gompertz",
    llogis        = "llogis"
  )
```

### Use `i` to make new list `p` (some elements same, some used in calculations to make new elements)

```{r}
p <- f_misc_param_generate_p(i)
```

::: {.callout-note collapse="true"}

The function `structure::f_misc_param_generate_p()` simply takes some of the elements from `i` and creates a new list `p`.

For example, these are both the same:

```{r}
p$basic$th_y
i$ui_time_horizon
```

See the full outline of what elements it takes by looking at the function:

```{r}
#' Function which creates an empty version of the parameters list p and populates
#' it using the inputs from i
#' 
#' @param i raw extracted inputs from Excel
#' 
f_misc_param_generate_p <- function(i) {
  
  p <- list(
    basic = list(
      th   = ceiling(i$ui_time_horizon * 365.25 / 7), 
      th_y = i$ui_time_horizon, 
      cl_d = i$i_cycle_length_weeks*7, 
      cl_w = i$i_cycle_length_weeks, 
      cl_y = i$i_cycle_length_weeks*7/365.25, 
      discQ = i$ui_disc_qaly,
      discC = i$ui_disc_cost,
      structure = str_trim(i$dd_model_struct)
    ),
    demo = list(
      table = data.table(i$R_table_ptchar)
    ), # patient demographic data
    seq   = list(), # treatment sequences. same for both model structures.
    surv  = list(), # Survival extrapolations (if needed for iteration, i.e. in part surv model). same for both model structures
    releff = list(), # Relative efficacy network, for use populating the disease model. same for both model structures
    costs  = list(
      mk = list(),
      ps = list(),
      settings = list(
        subsTx = data.table(i$R_table_sub_txts_prop_n_costs)
      )
    ), # All drug inputs after they've been processed and tidied up
    util  = list(
      mk = list(),
      ps = list()
    ), # All inputs to apply to the disease model
    ae    = list(
      mk = list(),
      ps = list()
    ), # Inputs to generate AE matrices AC and AQ
    misc  = list(
      mk = list(),
      ps = list(),
      plot = list(
        xlim_survplots_yr = 20
      )
    )
  )
  
  p$basic$n_cyc <- ceiling(p$basic$th) # rounding up to a whole number
  p$basic$t_cyc <- rep(0:p$basic$n_cyc)
  p$basic$t_yr  <- p$basic$t_cyc*7/365.25
  
  # discount factors - base-case edition. These will get replaced for scenarios affecting
  # discount rates or the time horizon
  p$basic$discFacQ <- f_discFac(p$basic$discQ,p$basic$t_yr)
  p$basic$discFacC <- f_discFac(p$basic$discC,p$basic$t_yr)
  
  return(p)
  
}
```

:::

### Add some more inputs to `p`

```{r}
p$basic$R_maxlines <- 4

p$basic$decision_problem <- i$decision_problem
```

::: {.callout-note collapse="true"}

I'm pretty sure that max lines is referring to the maximum number of treatment lines. The most it can be is 4. But I don't know if perhaps you can change this to 2 to reduce the number in model? Or if this is a standard unchanging parameter as the model is only designed to go up to 4?

:::

## Sequences

### Find all the possible combinations and orders of treatment and add to `i`

```{r}
i$sequences <- f_generate_sequences(
  comparators = i$List_comparators, 
  maxlines    = p$basic$R_maxlines
)
```

::: {.callout-note collapse="true"}

This adds a new element to `i` called `sequences`.

```{r}
head(i$sequences)
```

It's created using `sequences::f_generate_sequences()`. The inputs to this were:

```{r}
i$List_comparators
p$basic$R_maxlines
```

The output of the function is a table where each column is the line of therapy. The final column is always best supportive care (BSC). The first four columns reflect every possible order and combination of treatments (e.g. ABCD, ABCE, ABCF... and so on). The total possiblities are:

```{r}
dim(i$sequences)
```

:::

### Filter to valid combinations/sequences

```{r}
i$sequences <- as.data.frame(i$sequences)

populations <- i$i_nr_populations

seqs <- NULL
for (population in 1:populations) {
  cat("Applying sequence restrictions to population", population,"\n")
  
  s <- f_path_tx_restrict(
    sequences                = i$sequences,
    allowed                  = f_get_allowed_lists(i, population), #overall list of allowed drugs in this popn
    L1                       = f_get_L1_lists(i, population), # 1L drugs allowed in this popn
    L2                       = f_get_L2_lists(i, population), # 2L drugs allowed in this popn
    L3                       = f_get_L3_lists(i, population), # 3L drugs allowed in this popn
    L4                       = f_get_L4_lists(i, population), # 4L drugs allowed in this popn
    only_after               = f_get_only_after_lists(i, population), #list of restrictions where tx can be only after the listed txs
    not_immediate_after      = f_get_not_immediate_after_lists(i, population), #list of restrictions where tx can be only immediately before the listed txs
    one_in_list              = f_get_one_in_list_lists(i, population), #list of restrictions where only one of the tx in each list is allowed 
    only_after_one           = f_get_only_after_one_lists(i, population), #list of restrictions where only one of the listed treatments is allowed prior to current therapy 
    L2_only_after            = f_get_2L_only_after_lists(i, population), #list of 2L+ restrictions: if drug is used 2L, 3L or 4L, can only be after drug x
    L2_only_immediate_after  = f_get_2L_only_immediate_after_lists(i, population), #list of 2L+ restrictions: if drug is used 2L, 3L or 4L, can only be immediately after drug x
    L2_only_one              = f_get_2L_only_one_lists(i, population) #list of 2L+ drugs where only one of them allowed in a given sequence
  )
  s <- cbind(rep(paste0("pop", population),nrow(s)), s)
  colnames(s) <- paste0('V', seq_len(ncol(s))) # rbind no longer likes un-named columns so added this
  seqs <- rbind(seqs, s)
}
rownames(seqs) <- NULL
```

::: {.callout-note collapse="true"}

## Introduction to `f_path_tx_restrict`

`f_path_tx_restrict` is defined in two .R files: `rccFunctions.R` and `sequences.R`. In this script, we did not use `rccFunctions.R`, and just sourced `sequences.R`.

This has substantially reduced the number of rows with possible sequence combinations in `i$sequences`:

```{r}
dim(i$sequences)
```

It utilises several other functions from `sequences.R`, each taking the input of `i` and `population`, where population is an element from:

```{r}
i$i_nr_populations
```

We can see from the excel spreadsheet that this is the value for total populations from `Lists`, and that above it it mentions the popoulations:

* pop1	>12m since IO, favourable risk
* pop2	>12m since IO, intermed/poor risk
* pop3	<12m since IO, favourable risk
* pop4	<12m since IO, intermed/poor risk

IO refers to immuno-ocology. also known as immunotherapy.

The risks are as defined in the International Metastatic Renal Cell Carcinoma Database Consortium (IMDC) criteria. RCC can be defined as either:

* **Favourable-risk** disease/cancer/RCC
* **Intermediate- and poor-risk** disease/cancer/RCC

This then guides treatment decisions:

* Treatments for all risk groups (i.e. favourable, intermediate or poor) include "sunitinib, pazopanib, tivozanib or avelumab plus axitinib"
* Additional treatments for intermediate- or poor-risk cancer are "nivolumab plus ipilimumab, lenvatinib plus pembrolizumab, or cabozantinib" @national_institute_for_health_and_care_excellence_nice_cabozantinib_2024

:::

::: {.callout-note collapse="true"}

## Explanation of `f_get_allowed_lists()`

The first function used within `f_path_tx_restrict()` is `f_get_allowed_lists()` to get the value for `allowed`.

```{r}
f_get_allowed_lists <- function(i, population) {
  output <- i[grep("allowed", names(i))]
  output <- output[grep(paste0("pop", population), names(output))]
  output <- output[!(grepl("only_one_allowed", names(output)))]
  names(output) <- sub(paste0("List_","pop",population,"_"), "", names(output))
  f_check_drugnames(i, output)
  return(output)
}
```

The first thing this function does is find all the "allowed" lists from `i`. As you can see, there are several lists defined for each population.

```{r}
output <- i[grep("allowed", names(i))]
names(output)
```

It then filters to one of the populations (`pop1`, `pop2`, `pop3` or `pop4`). For example, for `pop1`...

```{r}
population <- 1

output <- output[grep(paste0("pop", population), names(output))]
output
```

It removes the lists that said `only_one_allowed`.

```{r}
output <- output[!(grepl("only_one_allowed", names(output)))]
output
```

Finally, it renames the lists to remove the words `List` and `pop1`(2/3/4).

```{r}
names(output) <- sub(paste0("List_","pop",population,"_"), "", names(output))
output
```

This checks that each of the names in the list match the names in `i$List_comparators`, and will stop the code and return an error message if any do not.

```{r}
i$List_comparators
```

```{r}
f_check_drugnames(i, output)
```

:::

::: {.callout-note collapse="true"}

## Returning to `f_path_tx_restrict`

The result from the function above is input into `f_path_tx_restrict` as `allowed`, and used in a single line, to remove drugs not allowed for that population:

```
s <- f_path_allowed(s, allowed[[1]])
```

As a reminder, `s` and `allowed[[1]]` are:

```{r}
# Input to f_path_tx_restrict(), as allowed = f_get_allowed_lists(i, population)
allowed <- output
allowed[[1]]
```

```{r}
# Input to f_path_tx_restrict()
sequences <- i$sequences
s <- sequences
head(s)
```

We apply the function `f_path_allowed()`...

```{r}
f_path_allowed <- function(perms, rule) {
  #objective of function is to identify perms that violate rule and exclude
  cat("applying rule:", rule, "are only allowed treatments.\n")
  cat("Permutations before applying rule:", nrow(perms), "\n")
  
  rule <- c(rule, "BSC", "")
  
  for (n in 1:ncol(perms)) {
    perms <- perms[perms[,n] %in% rule,]
  }
  
  cat("Permutations after applying rule :", nrow(perms),"\n")
  return(perms)
  
}
```

So in this case...

```{r}
perms <- s
rule <- allowed[[1]]

cat("applying rule:", rule, "are only allowed treatments.\n")
cat("Permutations before applying rule:", nrow(perms), "\n")
```

It adds BSC (best supportive care) and an empty element to the list of allowed treatments

```{r}
rule <- c(rule, "BSC", "")
```

It then loops through each of the lines of treatment (columns of `perms` - V1, V2, V3, V4, V5, V6), and only keeps the rows if the treatment in that column in that row is in the list of allowed treatments.

```{r}
for (n in 1:ncol(perms)) {
  perms <- perms[perms[,n] %in% rule,]
}

cat("Permutations after applying rule :", nrow(perms),"\n")
```

```{r}
f_path_allowed(s, allowed[[1]])
```

So, as a whole:

```{r}
for (population in 1:i$i_nr_populations) {
  sequences <- as.data.frame(i$sequences)
  allowed <- f_get_allowed_lists(i, population)
  print(paste0("Dropping drugs not allowed for pop", population))
  sequences
  s <- f_path_allowed(sequences, allowed[[1]])
  s
}
```

:::

::: {.callout-note collapse="true"}

## Explaining the other functions in `f_path_tx_restrict()`

As a reminder, these were:

```
s <- f_path_tx_restrict(
  sequences                = i$sequences,
  allowed                  = f_get_allowed_lists(i, population), #overall list of allowed drugs in this popn
  L1                       = f_get_L1_lists(i, population), # 1L drugs allowed in this popn
  L2                       = f_get_L2_lists(i, population), # 2L drugs allowed in this popn
  L3                       = f_get_L3_lists(i, population), # 3L drugs allowed in this popn
  L4                       = f_get_L4_lists(i, population), # 4L drugs allowed in this popn
  only_after               = f_get_only_after_lists(i, population), #list of restrictions where tx can be only after the listed txs
  not_immediate_after      = f_get_not_immediate_after_lists(i, population), #list of restrictions where tx can be only immediately before the listed txs
  one_in_list              = f_get_one_in_list_lists(i, population), #list of restrictions where only one of the tx in each list is allowed 
  only_after_one           = f_get_only_after_one_lists(i, population), #list of restrictions where only one of the listed treatments is allowed prior to current therapy 
  L2_only_after            = f_get_2L_only_after_lists(i, population), #list of 2L+ restrictions: if drug is used 2L, 3L or 4L, can only be after drug x
  L2_only_immediate_after  = f_get_2L_only_immediate_after_lists(i, population), #list of 2L+ restrictions: if drug is used 2L, 3L or 4L, can only be immediately after drug x
  L2_only_one              = f_get_2L_only_one_lists(i, population) #list of 2L+ drugs where only one of them allowed in a given sequence
)
```

We have functions that find the overall list of allowed drugs for the population, and then the drugs allowed for each line of treatment.

```{r}
print("Overall list of allowed drugs")
f_get_allowed_lists(i, i$i_nr_populations[1])

print("L1")
f_get_L1_lists(i, i$i_nr_populations[1])
print("L2")
f_get_L2_lists(i, i$i_nr_populations[1])
print("L3")
f_get_L3_lists(i, i$i_nr_populations[1])
print("L4")
f_get_L4_lists(i, i$i_nr_populations[1])
```

We then have treatments that can only come after or before certain treatments. As illustrated in Figure 1 in the pathway model report, you can see examples like how:

* Axitinib - can only administer after tyrosine kinase inhibitor (TKI) (e.g. sunitinib) or cytokine
* Everolimus - can only administrater after vascular endothelial growth factor (VEGF)

```{r}
print("list of restrictions where tx can be only after the listed txs")
f_get_only_after_lists(i, i$i_nr_populations[1])

print("list of restrictions where tx can be only immediately before the listed txs")
f_get_not_immediate_after_lists(i, i$i_nr_populations[1])

print("list of restrictions where only one of the tx in each list is allowed ")
f_get_one_in_list_lists(i, i$i_nr_populations[1])

print("list of restrictions where only one of the listed treatments is allowed prior to current therapy ")
f_get_only_after_one_lists(i, i$i_nr_populations[1])

print("list of 2L+ restrictions: if drug is used 2L, 3L or 4L, can only be after drug x")
f_get_2L_only_after_lists(i, i$i_nr_populations[1])

print("list of 2L+ restrictions: if drug is used 2L, 3L or 4L, can only be immediately after drug x")
f_get_2L_only_immediate_after_lists(i, i$i_nr_populations[1])

print("list of 2L+ drugs where only one of them allowed in a given sequence")
f_get_2L_only_one_lists(i, i$i_nr_populations[1])
```

Within `f_path_tx_restrict()`, various functions are then applied to implement the logic of these lists. For example:

* `f_path_drug_lines()` is used to remove drugs from a line unless it is listed in `L1`, `L2`, `L3`, or `L4`.
* For `only_after`, `f_path_notAllowedImmediateAfter()` is used to remove permutations that have treatment before drugs in rule

And so on. Overall, we then get:

```{r}
population <- i$i_nr_populations[1]

s <- f_path_tx_restrict(
  sequences                = i$sequences,
  allowed                  = f_get_allowed_lists(i, population), #overall list of allowed drugs in this popn
  L1                       = f_get_L1_lists(i, population), # 1L drugs allowed in this popn
  L2                       = f_get_L2_lists(i, population), # 2L drugs allowed in this popn
  L3                       = f_get_L3_lists(i, population), # 3L drugs allowed in this popn
  L4                       = f_get_L4_lists(i, population), # 4L drugs allowed in this popn
  only_after               = f_get_only_after_lists(i, population), #list of restrictions where tx can be only after the listed txs
  not_immediate_after      = f_get_not_immediate_after_lists(i, population), #list of restrictions where tx can be only immediately before the listed txs
  one_in_list              = f_get_one_in_list_lists(i, population), #list of restrictions where only one of the tx in each list is allowed 
  only_after_one           = f_get_only_after_one_lists(i, population), #list of restrictions where only one of the listed treatments is allowed prior to current therapy 
  L2_only_after            = f_get_2L_only_after_lists(i, population), #list of 2L+ restrictions: if drug is used 2L, 3L or 4L, can only be after drug x
  L2_only_immediate_after  = f_get_2L_only_immediate_after_lists(i, population), #list of 2L+ restrictions: if drug is used 2L, 3L or 4L, can only be immediately after drug x
  L2_only_one              = f_get_2L_only_one_lists(i, population) #list of 2L+ drugs where only one of them allowed in a given sequence
)
```

:::

```{r}
i$sequences <- seqs
rm(s, seqs, populations)
```

## Import IPD and look-ups

### Import individual patient-level data (IPD) (pseudo/synthetic trial data)

::: {.callout-warning collapse="true"}

Set excel path at start of script instead of here

:::

```{r}
i$surv <- list()

if (file.exists(excel_path2)) {
  wb <- f_excel_extract(excel_path2, verbose = TRUE)
  i$surv$pld <- as.data.table(wb$`_xlnm._FilterDatabase`)
  rm(wb)
} else {
  wb <- f_excel_extract(rstudioapi::selectFile(
    caption = "Select the IPD file (IPD_R_input_noACIC.xlsx)",
    label = "IPD_R_input_noACIC.xlsx",
    path = "./1_Data/",
    filter = "Excel Files (*.xlsx)",
    existing = TRUE
  ), verbose = TRUE)
  i$surv$pld <- as.data.table(wb$`_xlnm._FilterDatabase`)
  
}

i$surv$pld <- i$surv$pld[,list(population,line,molecule,trial,endpoint,timew,event_censor)]

i$surv$pld[timew ==0,"timew"] <- 1/7
```

::: {.callout-note collapse="true"}

The file we are importing contains pseudo-individual patient data (IPD) for all the clinical trials (i.e. simulated data to replace clinical trial data considered confidential).

This uses `f_excel_extract()` like before, this time from `IPD_R_input_noACIC.xlsx`. It produces `wb` which is a list with one item: `wb$_xlnm._FilterDatabase`.

```{r}
wb <- f_excel_extract(excel_path2, verbose = TRUE)
length(wb)
```

That is simply the table from the `IPD` sheet of that dataframe.

```{r}
df <- as.data.table(wb$`_xlnm._FilterDatabase`)
dim(df)
head(df)
```

The script then filter to only the columns: `list(population,line,molecule,trial,endpoint,timew,event_censor)`.

Then it finds the rows where the column `timew`==0, and replaces their values with 1/7. In `Model_Structure.py`, they explain that this is because we don't allow zero survival times, so has to be at least 1 day (and since TuotA is in weeks, this is 1/7... not sure what TuotA is).

Looking at what this dataframe contains...

```{r}
unique(df$population)

unique(df$line)

unique(df$molecule)

unique(df$trial)

unique(df$endpoint)

describe(df$timew)

unique(df$event_censor)
```

`molecule`: combination therapies are under same number

`trial`: trial id *within* population line and molecule to set them apart (so often just 1)

`event_censor`: event coded as 1, censor as 0

Final result:

```{r}
head(i$surv$pld)
```

:::

### Get look-ups for each column

```{r}
i$id$ipd <- list(
  pop      = i$r_pld_lookup_pop$Number[!is.na(i$r_pld_lookup_pop$Number)],
  line     = i$r_pld_lookup_line$Number[!is.na(i$r_pld_lookup_line$Number)],
  mol      = i$r_pld_lookup_mol$Number[!is.na(i$r_pld_lookup_mol$Number)],
  trial    = i$r_pld_lookup_trial$Number[!is.na(i$r_pld_lookup_trial$Number)],
  endpoint = i$r_pld_lookup_endpoint$Number[!is.na(i$r_pld_lookup_endpoint$Number)]
)
```

::: {.callout-note collapse="true"}

Gets the unique values from each column (excluding NaN)

```{r}
i$id$ipd
```

:::

```{r}
names(i$id$ipd$pop)      <- paste0("pop_"     , i$id$ipd$pop)
names(i$id$ipd$line)     <- paste0("line_"    , i$id$ipd$line)
names(i$id$ipd$mol)      <- paste0("mol_"     , i$id$ipd$mol)
names(i$id$ipd$trial)    <- paste0("trial_"   , i$id$ipd$trial)
names(i$id$ipd$endpoint) <- paste0("endpoint_", i$id$ipd$endpoint)
```

::: {.callout-note collapse="true"}

Adds names for each which combine the column name with the value

```{r}
i$id$ipd
```

:::

```{r}
i$lookup$ipd <- list(
  pop      = data.table(i$r_pld_lookup_pop)[Description != 0],
  line     = data.table(i$r_pld_lookup_line)[Description != 0],
  mol      = data.table(i$r_pld_lookup_mol)[Description != 0],
  trial    = data.table(i$r_pld_lookup_trial)[Description != 0],
  endpoint = data.table(i$r_pld_lookup_endpoint)[Description != 0]
)
```

::: {.callout-note collapse="true"}

Makes a list containing dataframes with the look-ups for each of those columns (which were stored in `i`).

```{r}
i$lookup$ipd
```

:::

```{r}
i$lookup$ipd$line$seq_col <- paste0("V",2:(nrow(i$lookup$ipd$line)+1))
i$lookup$ipd$line$R_id    <- paste0("line_",1:nrow(i$lookup$ipd$line))
```

::: {.callout-note collapse="true"}

Create a list of V2, V3, V4...

And line_1, line_2, line_3...

For length of the `line` (i.e. 5 long: 1st, 2nd, 3rd or 4th line of treatment, or best supportive care (BSC)),

```{r}
i$lookup$ipd$line$seq_col
i$lookup$ipd$line$R_id
```

:::

```{r}
i$lookup$dist <- i$r_pld_lookup_dist
```

::: {.callout-note collapse="true"}

Save the look up for distributions under `i$lookup$dist` (just making another entry in `i` but under a different name)

```{r}
i$lookup$dist
```

:::

```{r}
i$lookup$trt <- i$lookup$ipd$mol$Number
names(i$lookup$trt) <- i$lookup$ipd$mol$RCC_input_desc
names(i$lookup$trt)[length(i$lookup$trt)] <- "BSC"
```

::: {.callout-note collapse="true"}

Create a treatment lookup but getting the numbers for each molecule, and their equivalent name from `RCC_input_desc`

```{r}
i$lookup$trt
```

:::

### Some other pre-processing

```{r}
p$basic$lookup <- i$lookup
p$basic$id <- i$id

i$seq_clean <- data.table(i$sequences)
```

::: {.callout-note collapse="true"}

Add look-ups and ids from `i` to `p`

```{r}
p$basic$lookup
p$basic$id
```

Convert sequences to a data table

```{r}
head(i$seq_clean)
```

:::

```{r}
i$seq_clean$V1 <- paste0("pop_",as.numeric(substr(i$seq_clean$V1,4,4)) - 1)
i$seq_pops <- unique(i$seq_clean$V1)
names(i$seq_pops) <- i$seq_pops
```

::: {.callout-note collapse="true"}

Changes `i$seq_clean$V1` from having pop_1 to pop_4, to having pop_0 to pop_3.

```{r}
i$seq_pops
```

:::

```{r}
i$seq_clean <- lapply(i$seq_pops, function(popu) {
  tmp <- i$seq_clean[V1 == popu,-1]
  colnames(tmp) <- i$lookup$ipd$line$R_id[1:(p$basic$R_maxlines + 1)]
  tmp
})
```

::: {.callout-note collapse="true"}

Loops through each of the populations, and then gets the treatment sequences for that population, and saves them under new column names (line_1 to line_5), using the lookup, and saving them as seperate dataframes for each population.

```{r}
i$lookup$ipd$line
```

```{r}
head(i$seq_clean$pop_0)
```

:::

```{r}
i$seq_n <- lapply(i$seq_clean, function(popu) {
  as.data.table(lapply(popu, function(co) i$lookup$trt[co]))
})
```

::: {.callout-note collapse="true"}

Create new item `i$seq_n`. It looks through the four sequence tables in `i$seq_clean`. It then loops through each column in each of those dataframes (i.e. line 1, line 2, line 3...) and uses `i$lookup$trt` to convert from the name of the treatment to the numeric identifier for that treatment.

Look up table:

```{r}
i$lookup$trt
```

Output example:

```{r}
head(i$seq_n$pop_0)
```

:::

```{r}
i$seq_ref <- lapply(i$seq_clean, function(popu) {
  tmp <- as.data.table(lapply(popu, function(co) {
    vals <- paste0("mol_",i$lookup$trt[co])
    ifelse(vals == "mol_NA",NA,vals)
  }))
})
```

::: {.callout-note collapse="true"}

Creates `i$seq_ref`. This just takes the table with the drug in each line of treatment, but instead of just converting it to the number representing each treatment, it adds the mol_ suffix, e.g. mol_4, mol_5

```{r}
head(i$seq_ref$pop_0)
```

:::

```{r}
p$seq$n   <- i$seq_n
p$seq$ref <- i$seq_ref
p$seq$qc <- i$seq_clean
```

## Partitioned survival analysis (PartSA)

```{r}
i$surv$lab_pld <- list()

i$surv$lab_pld$population <- i$lookup$ipd$pop$Number
names(i$surv$lab_pld$population) <- i$lookup$ipd$pop$Description

i$surv$lab_pld$line <- i$lookup$ipd$line$Number
names(i$surv$lab_pld$line) <- i$lookup$ipd$line$Description

i$surv$lab_pld$molecule <- i$lookup$ipd$mol$Number
names(i$surv$lab_pld$molecule) <- i$lookup$ipd$mol$Description

i$surv$lab_pld$trial <- i$lookup$ipd$trial$Number
names(i$surv$lab_pld$trial) <- i$lookup$ipd$trial$Description

i$surv$lab_pld$endpoint <- i$lookup$ipd$endpoint$Number
names(i$surv$lab_pld$endpoint) <- i$lookup$ipd$endpoint$Description
```

::: {.callout-note collapse="true"}

Makes a named list from each of the look ups.

For example it uses these...

```{r}
i$lookup$ipd$pop$Number
i$lookup$ipd$pop$Description
```

...to make this...

```{r}
i$surv$lab_pld$population
```
:::

```{r}
i$surv$lab_pld$dat <- i$surv$pld
i$surv$lab_pld$dat$population <- names(i$surv$lab_pld$population)[match(i$surv$lab_pld$dat$population,i$surv$lab_pld$population)]
i$surv$lab_pld$dat$line       <- names(i$surv$lab_pld$line)[match(i$surv$lab_pld$dat$line,i$surv$lab_pld$line)]
i$surv$lab_pld$dat$molecule   <- names(i$surv$lab_pld$molecule)[match(i$surv$lab_pld$dat$molecule,i$surv$lab_pld$molecule)]
i$surv$lab_pld$dat$trial      <- names(i$surv$lab_pld$trial)[match(i$surv$lab_pld$dat$trial,i$surv$lab_pld$trial)]
i$surv$lab_pld$dat$endpoint   <- names(i$surv$lab_pld$endpoint)[match(i$surv$lab_pld$dat$endpoint,i$surv$lab_pld$endpoint)]
```

```{r}
i$surv$lab_pld$dat
```